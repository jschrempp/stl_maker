# functions to help build stl files
import numpy as np
import struct 
from bitstring import BitArray


def Initialize_stl_file(filepath, filetype, num_facets, solid_name = ""):
	'''Write the front end of the stl file that goes before the facet data'''
	if filetype == "txt":
		with open(filepath, "w") as stl_file:
			stl_file.write("solid "+solid_name +"\n")
		return
	elif filetype == "bin":
		with open(filepath, "wb") as stl_file:
			#First, create and write an 80 character header - any characters will do
			#header = int(0).to_bytes(80,byteorder="little",signed=False)
			header = bytearray("STL Builder output          3         4         5         6         7         80",'utf8')
			stl_file.write(header)
			#Second, write a 4 byte little endian unsigned integer indicating the numebr of facets

			stl_file.write(num_facets.to_bytes(4,byteorder="little",signed=False))
			pass
		
		return

def Finalize_stl_file(triangle_count, filepath, filetype, solid_name = "" ):
	'''Write the end of the stl file that goes after the facet data'''
	if filetype  == "txt":
		with open(filepath, "w") as stl_file:
			stl_file.write("endsolid \n" + solid_name )
	elif filetype == "bin":
		#no ending stuff for a binary file 
		return




class STL_Facet():
	def __init__(self, pt1, pt2, pt3):
		#Calculate the normal for this facet
		
		self.p1 = np.array([pt1[0], pt1[1],pt1[2]])
		self.p2 = np.array([pt2[0], pt2[1],pt2[2]])
		self.p3 = np.array([pt3[0], pt3[1],pt3[2]])

		# These two vectors are in the plane
		v1 = self.p3 - self.p1
		v2 = self.p2 - self.p1

		# the cross product is a vector normal to the plane
		cp = np.cross(v1, v2)
		self.normal_a, self.normal_b, self.normal_c = cp


	def Append_facet_to_file(self, filepath, filetype):
		if filetype == "txt":
			with open(filepath, "a+") as stl_file:
				stl_file.write("facet normal "+ "%E"%self.normal_a + " " + "%E"%self.normal_b + " " +  "%E"%self.normal_c +"\n") # normal, a, b, c
				stl_file.write("\touter loop\n")
				stl_file.write("\t\tvertex " + "%E"%self.p1[0] + " " + "%E"%self.p1[1] + " " +  "%E"%self.p1[2] +"\n") # first corner points 0,1,2
				stl_file.write("\t\tvertex " + "%E"%self.p2[0] + " " + "%E"%self.p2[1] + " " +  "%E"%self.p2[2] +"\n") # second corner points 0,1,2
				stl_file.write("\t\tvertex " + "%E"%self.p3[0] + " " + "%E"%self.p3[1] + " " +  "%E"%self.p3[2] +"\n") # third corner points 0,1,2
				stl_file.write("\tendloop\n")
				stl_file.write("endfacet\n")
				
				
		elif filetype == "bin":
			with open(filepath, "ab") as stl_file:
				# I used the info here to figure out how to write these IEEE 32bit floating point numbers
				# from https://www.linuxquestions.org/questions/programming-9/write-a-file-fo-data-array-with-float-values-in-a-binary-format-in-python-937020/
				
				#Write the normal and each of the vertexes in IEEE floating point numbers
				stl_file.write(struct.pack('<%df' % 3, *[self.normal_a, self.normal_b, self.normal_c]))
				
				# Now write each of the three points in IEEE floating point numbers
				stl_file.write(struct.pack('<%df' % 3, *[self.p1[0], self.p1[1],self.p1[2]]))
				stl_file.write(struct.pack('<%df' % 3, *[self.p2[0], self.p2[1],self.p2[2]]))
				stl_file.write(struct.pack('<%df' % 3, *[self.p3[0], self.p3[1],self.p3[2]]))
				
				#Next, write 8 bytes as an attribute thing. Copies these (int 115 and int 73  from a file generated by Fusion 360. 
				stl_file.write(int(115).to_bytes(1,byteorder="little",signed=False))
				stl_file.write(int(78).to_bytes(1,byteorder="little",signed=False))

		else: print( "wtf? filetype not found" , filetype)
